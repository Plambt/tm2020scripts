/**
 *
 * Stunts for TrackMania 2020
 *
 * written by dassschaf / UD Timmy
 *
 */

// Extends base mode script of TM 2020:
#Extends "Libs/Nadeo/TMNext/TrackMania/Modes/TMNextBase.Script.txt"

// ---------------------------------- //
// Script Info
#Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const  Version     		"0"
#Const  ScriptName  		"Stunts2020.Script.txt"
#Const  C_ModeName          "Stunts2020"
#Const  Description         _("In $<$6f9Stunt mode$>, the goal is to make as much points by tricks in the air as possible before the time is over. Finishing too late and respawning cause point deduction. The winner is the player with the highest score. \n This mode is inspired by the original Stunt mode known from TM 1 or Spaii's stunts titlepack for TM 2.")

// ---------------------------------- //
// Libraries

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib

#Include "Libs/Nadeo/ModeLibs/Legacy/Layers2.Script.txt" as Layers

// ---------------------------------- //
// Settings
// #Setting S_NAME VALUE as _("TEXT")

#Setting S_TimeLimit 300 as _("Time Limit:") ///< as ... for server setup
#Setting S_ShowDebugInfo True as _("Show Debug info")

// ---------------------------------- //
// Constants
// #Const C_NAME VALUE
#Const C_UploadRecord False

// ---------------------------------- //
// Global variables
declare Text[] G_Players; ///< used to figure out indices for other global arrays
declare Vec3[] G_CurrentRotation;
declare Vec3[] G_PreviousVector;


// ---------------------------------- //
// Extends

***Match_LogVersion***
***
    // register the script to the log
    Log::RegisterScript(ScriptName, Version);
*** // Match_LogVersion



***Match_Rules***
***
    // register game mode information
    ModeInfo::SetName(C_ModeName);
    ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
    ModeInfo::SetRules(Description);
    ModeInfo::SetStatusMessage(_("TYPE: Free for all\nOBJECTIVE: Set the best score on the track."));

*** // Match_Rules



***Match_StartServer***
***
    // Initialize Gamemode
    Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_GiveUpBeforeFirstCheckpoint);

*** // Match_StartServer



***Match_InitMap***
***
    // Map initialization
    G_Players.clear();
    G_PreviousVector.clear();
    G_CurrentRotation.clear();

    foreach (Player in Players) {
        G_Players.add(Player.User.Login); ///< nth element
        G_PreviousVector.add(<0., 0., 0.>);
        G_CurrentRotation.add(<0., 0., 0.>);
    }

*** // Match_InitMap



***Match_StartMap***
***
    // Map actual start


    // Start players for the race
    foreach (Player in Players) {
        Race::Start(Player);
    }

*** // Match_StartMap



***Match_InitTurn***
***
    // Turn initialitzation
    yield;

*** // Match_InitTurn



***Match_StartTurn***
***
    // Turn start
    ModeStatusMessage = "Current map : "^Map.MapInfo.Name;

*** // Match_StartTurn



***Match_PlayLoop***
***
    // ------------------
    // Pending Events Handler
    foreach (Event in PendingEvents) {
        // get player index
        declare Player <=> Event.Player;
        declare Integer PlayerIndex = G_Players.keyof(Player.User.Login);

    }

    // ------------------
    // Player phsyics debug info
    foreach (Player in Players) {

        // get player index
        declare Integer PlayerIndex = G_Players.keyof(Player.User.Login);

        // re-spawn mechanics
        if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
        {
            Race::Start(Player);
            G_PreviousVector[PlayerIndex] = Player.AimDirection;
            G_CurrentRotation[PlayerIndex] = <0., 0., 0.>;
        }

        // score and jump calculation
        if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {

            // checking rotation does not exactly work yet
            declare Vec3 CurrentAim = Player.AimDirection;

            declare Real XChange = MathLib::Angle(CurrentAim.X, G_PreviousVector[PlayerIndex].X);
            declare Real YChange = MathLib::Angle(CurrentAim.Y, G_PreviousVector[PlayerIndex].Y);
            declare Real ZChange = MathLib::Angle(CurrentAim.Z, G_PreviousVector[PlayerIndex].Z);

            G_CurrentRotation[PlayerIndex].X += XChange;
            G_CurrentRotation[PlayerIndex].Y += YChange;
            G_CurrentRotation[PlayerIndex].Z += ZChange;

            G_PreviousVector[PlayerIndex] = CurrentAim;


            // debug info
            if (S_ShowDebugInfo) {
                declare Text ManialinkDebugInfo;

                declare Real InputSteer = Player.InputSteer;
                declare Integer FlyingDuration = Player.FlyingDuration;
                declare Real FlyingDistance = Player.FlyingDistance;
                declare Integer WheelsContactCount = Player.WheelsContactCount;
                declare Boolean IsTouchingGround = Player.IsTouchingGround;
                declare Real Upwardness = Player.Upwardness;
                declare Real PosX = Player.Position.X;
                declare Real PosY = Player.Position.Y;
                declare Real PosZ = Player.Position.Z;
                declare Real AimX = Player.AimDirection.X;
                declare Real AimY = Player.AimDirection.Y;
                declare Real AimZ = Player.AimDirection.Z;
                


                ManialinkDebugInfo = """
                <label pos="0 1" z-index="0" 
                text="
                Steer: {{{InputSteer}}}
                Fly Duration: {{{FlyingDuration}}}
                Fly Distance: {{{FlyingDistance}}}
                On Ground? {{{IsTouchingGround}}}
                #Wheels: {{{WheelsContactCount}}}
                Upwardness: {{{Upwardness}}}
                Coordinates: X={{{PosX}}}, Y={{{PosY}}}, Z={{{PosZ}}}
                Aim Direction: X={{{AimX}}}, Y={{{AimY}}}, Z={{{AimZ}}}
                Car Rotation: X={{{G_CurrentRotation[PlayerIndex].X}}}, Y={{{G_CurrentRotation[PlayerIndex].Y}}}, Z={{{G_CurrentRotation[PlayerIndex].Z}}}
                "/>
                """;

                // get debug info for the player
                Layers::Create("ManialinkDebugInfo", ManialinkDebugInfo);
                Layers::SetType("ManialinkDebugInfo", CUILayer::EUILayerType::Normal);
                Layers::Attach("ManialinkDebugInfo", Player);
            }
        }
    }



***

// this somehow prevents an EOF error?
Void dummy() {
}
