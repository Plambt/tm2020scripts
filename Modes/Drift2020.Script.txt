/**
 *
 * Drifting for TrackMania 2020
 *
 * written by dassschaf / UD Timmy
 *
 */

// Extends base mode script of TM 2020:
#Extends "Libs/Nadeo/TMNext/TrackMania/Modes/TMNextBase.Script.txt"

// ---------------------------------- //
// Script Info
#Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const  Version     		"0"
#Const  ScriptName  		"Drift2020.Script.txt"
#Const  C_ModeName          "Drift2020"
#Const  Description         _("In $<$Drift mode$>, the goal is to make as much points as possible through drifting over the track. The higher your angle of attack and speed are, the higher the points you gain. The winner is the player with most points at the end of the round.")

// ---------------------------------- //
// Libraries
//
// Utility libraries:
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib

// Various libraries:
#Include "Libs/Nadeo/ModeLibs/Legacy/Layers2.Script.txt" as Layers

// UI-Modules:
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/ScoresTable_Server.Script.txt" as UIModules_ScoresTable

// ---------------------------------- //
// Settings
// #Setting S_NAME VALUE as _("TEXT")

#Setting S_TimeLimit            300         as _("Time Limit:")
#Setting S_ShowDebugInfo        True        as _("Show Debug info")
#Setting S_EnableCollisions     True        as _("Enable Collisions between cars")
#Setting S_RespawnPenalty       500         as _("Respawn Penalty in pts")
#Setting S_CollisionPenalty     0           as _("Collision Penalty in pts")

// ---------------------------------- //
// Constants
// #Const C_NAME VALUE
#Const C_UploadRecord False //< idk

// ---------------------------------- //
// Structures
#Struct K_PlayerInfo {
    Text Login;             //< Player Login for identification

    Integer CurrentScore;   //< current run's score
    Boolean IsSkidding;     //< whether player is drifting or not
    Real CurrentSkidScore;  //< score of the current drift, added after drift end, discarded if collision
    Real LastTickSpeed;     //< Player.Speed from last tick, used for determining collisions
}

// ---------------------------------- //
// Global variables
declare Text[] G_Players; ///< used to figure out indices for G_Scores -- maybe replace with associative arrays?
declare Integer[] G_Scores; 
declare Boolean[] G_IsSkidding;
declare Real[] G_CurrentSkidScore;
declare K_PlayerInfo[] G_PlayerInfo;


// ---------------------------------- //
// Extends

***Match_LogVersion***
***
    // register the script to the log
    Log::RegisterScript(ScriptName, Version);
*** // Match_LogVersion



***Match_Rules***
***
    // register game mode information
    ModeInfo::SetName(C_ModeName);
    ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
    ModeInfo::SetRules(Description);
    ModeInfo::SetStatusMessage(_("TYPE: Free for all\nOBJECTIVE: Set the best score on the track."));

*** // Match_Rules



***Match_StartServer***
***
    // Initialize Gamemode
    Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_GiveUpBeforeFirstCheckpoint);
    
    // Gamemode settings
    UsePvPCollisions = S_EnableCollisions;
    UseGuns = True; //< I just wanna see what happens


*** // Match_StartServer



***Match_InitMap***
***
    // Map initialization
    G_Scores.clear();
    G_Players.clear();
    G_IsSkidding.clear();
    G_CurrentSkidScore.clear();

    // clear info array
    G_PlayerInfo.clear();

    // repopulate array for player count
    foreach (Player in Players) 
        G_PlayerInfo.add(K_PlayerInfo{Login = Player.User.Login, CurrentScore = 0, IsSkidding = False, CurrentSkidScore = 0., LastTickSpeed = 0.});
    
*** // Match_InitMap



***Match_StartMap***
***
    // Map actual start


    // Start players for the race
    foreach (Player in Players) {
        Race::Start(Player);
    }

*** // Match_StartMap



***Match_InitTurn***
***
    // Turn initialitzation
    yield;

*** // Match_InitTurn



***Match_StartTurn***
***
    // Turn start
    yield;

*** // Match_StartTurn



***Match_PlayLoop***
***
    // actual game mechanics?!

    // ------------------
    // Pending Events Handler
    foreach (Event in PendingEvents) {
        declare Player <=> Event.Player;
        declare Integer PId = GetPlayerIndexFromLogin(Player.User.Login);

        switch (Event.Type) {
            // Player joins game:
            case CSmModeEvent::EType::OnPlayerAdded: {
                G_PlayerInfo.add(K_PlayerInfo{Login = Player.User.Login, CurrentScore = 0, IsSkidding = False, CurrentSkidScore = 0., LastTickSpeed = 0.});
            }

            // Player traverses finish or lap
            case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
                if (Event.IsFinish || Event.IsNewLap) {
                    // player passed finish line, score handling here
                    
                    // add ongoing skid to score
                    G_PlayerInfo[PId].CurrentScore += MathLib::NearestInteger(G_PlayerInfo[PId].CurrentSkidScore);

                    // apply score to the actual score list if better
                    if (G_PlayerInfo[PId].CurrentScore > Player.Score.Points)
                        Player.Scoer:points = G_PlayerInfo[PId].CurrentScore;
                    
                    G_PlayerInfo[PId].CurrentScore = 0;
                    G_PlayerInfo[PId].CurrentSkidScore = 0.;
                    G_PlayerInfo[PId].IsSkidding = False;
                }
            }

            // Player requests respawn
            case CSmModeEvent::EType::OnPlayerRequestRespawn: {
                // player respawns

                // reset ongoing skid
                ResetOngoingSkid(PId, S_RespawnPenalty);
            }

            // Player's Vehicle collides
            case CSmModeEvent::EType::OnVehicleCollision: {
                // on vehicle collision

                // reset ongoing skid
                ResetOngoingSkid(PId, 0);
            }

            // Player's Vehicle collides with another Vehicle
            case CSmModeEvent::EType::OnVehicleVsVehicleCollision: {
                // on vehicle-vehicle collision between players

                // reset ongoing skid
                ResetOngoingSkid(PId, 0);
            }
        }


    }

    // ------------------
    // Manage per-player actions
    foreach (Player in Players) {
        declare Integer PId = GetPlayerIndexFromLogin()

        // re-spawning
        if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {   
            // spawn player
            Race::Start(Player);
        
            // reset skid and run score
            G_PlayerInfo[PId].CurrentScore = 0;
            ResetOngoingSkid(PId, 0);
        }

        // reading out physics
        if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {

            // fetch skidding information
            declare Integer SkiddingDuration = Player.SkiddingDuration;
            declare Real SkiddingDistance = Player.SkiddingDistance;
            declare Integer WheelsSkiddingCount = Player.WheelsSkiddingCount;
            declare Integer WheelsContactCount = Player.WheelsContactCount;
            declare Real Speed = Player.Speed;

            // crash detection
            if (MathLib::Abs(Speed - G_PlayerInfo[PId]) > 15)
            {
                // collision!
                ResetOngoingSkid(PId, S_CollisionPenalty);
            }
            
            // score relevant information
            declare Real SkidAngle; //<- radians, 3.14 == 180° turned skiddderidoo
            declare Real Points;

            // score calculation
            // check if not airborne
            if (WheelsContactCount >= 2 && WheelsSkiddingCount >= 2 || WheelsContactCount == 4) {
                SkidAngle = MathLib::Abs(MathLib::OrientedAngle(Player.Velocity, Player.AimDirection));

                // Check for sufficient skid angle and speed (m/s)
                // if the car's angle between velocity and aim vector is HIGHER than 135° it is not a valid drift
                // to prevent driving backwards as meta strategy
                if (SkidAngle > 0.1 && SkidAngle < 2.35 && Speed > 12 || WheelsSkiddingCount > 0 && SkidAngle < 2.35) {
                    // car is skidding, calculate points
                    G_PlayerInfo[PId].IsSkidding = True;
                    Points = SkidAngle * Speed * 0.05;
                    G_PlayerInfo[PId].CurrentSkidScore += Points;
                
                } else {
                    // car is not skidding
                    // add skid score to run score
                    if (G_PlayerInfo[PId].IsSkidding)
                        G_PlayerInfo[PId].CurrentScore += MathLib::NearestInteger(G_PlayerInfo[PId].CurrentSkidScore);
                        
                    // reset values
                    ResetOngoingSkid(PId, 0);
                }
    
            } else {

                // car does not qualify for skidding, car airborne
                if (G_PlayerInfo[PId].IsSkidding)
                    G_PlayerInfo[PId].CurrentScore += MathLib::NearestInteger(G_PlayerInfo[PId].CurrentSkidScore);
                
                // reset values
                ResetOngoingSkid(PId, 0);
                SkidAngle = 0.0;
                Points = 0.0;
            }

            if (S_ShowDebugInfo) {
                // car velocity
                declare Real VelX = Player.Velocity.X;
                declare Real VelY = Player.Velocity.Y;
                declare Real VelZ = Player.Velocity.Z;

                // car direction
                declare Real AimX = Player.AimDirection.X;
                declare Real AimY = Player.AimDirection.Y;
                declare Real AimZ = Player.AimDirection.Z;

                // player input
                declare Real InputSteer = Player.InputSteer;

                // make manialink
                declare Text ManialinkDebugInfo;
                ManialinkDebugInfo = """
                <label pos="0 1" z-index="0" 
                text="
                Skidding? {{{G_PlayerInfo[PId].IsSkidding}}}
                Speed: {{{Speed}}}
                Skid Duration: {{{SkiddingDuration}}}
                Skid Distance: {{{SkiddingDistance}}}
                Skid Wheels # {{{WheelsSkiddingCount}}}
                Grnd Wheels # {{{WheelsContactCount}}}
                Vel Direction: X={{{VelX}}}, Y={{{VelY}}}, Z={{{VelZ}}}
                Car Direction: X={{{AimX}}}, Y={{{AimY}}}, Z={{{AimZ}}}
                Skid Angle: {{{SkidAngle}}}
                Points: {{{Points}}}
                Skid Points: {{{G_PlayerInfo[PId].CurrentSkidScore}}}
                Total Points: {{{G_PlayerInfo[PId].CurrentScore}}}
                Current Score: {{{Player.Score.Points}}}
                "/>
                """;

                // get debug info for the player
                Layers::Create("ManialinkDebugInfo", ManialinkDebugInfo);
                Layers::SetType("ManialinkDebugInfo", CUILayer::EUILayerType::Normal);
                Layers::Attach("ManialinkDebugInfo", Player);
            }
        }
    }

***

***Match_EndMap***
***

    // Destroy UI layers
    Layers::Destroy("ManialinkDebugInfo");


*** // Match_EndMap

// ------------------
/** 
 * @param _PId      Player's ID
 * @param _Penalty  Penalty in pts to be deducted from Player's score
 */
Void ResetOngoingSkid(Integer _PId, Integer _Penalty) {

    // reset ongoing skid
    G_PlayerInfo[_PId].CurrentSkidScore = 0.;
    G_PlayerInfo[_PId].IsSkidding = False;

    // deduct penalty points
    G_PlayerInfo[_PId].CurrentScore -= 500;

    // fix negative scores
    if (G_PlayerInfo[_PId].CurrentScore < 0)
        G_PlayerInfo[_PId].CurrentScore = 0;
}

// ------------------
/**
 * @param _Login    Player's Login
 *
 * @return          Player's Index of his data struct in G_PlayerInfo
 */
Integer GetPlayerIndexFromLogin(Text _Login) {

    // Iterate over player info structs, return PId once matching player is found
    for (I, 1, G_PlayerInfo.count - 1) {
        if (G_PlayerInfo[I].Login == _Login)
            return I;
    }

    // return -1 if there is no fitting player
    return -1;
}